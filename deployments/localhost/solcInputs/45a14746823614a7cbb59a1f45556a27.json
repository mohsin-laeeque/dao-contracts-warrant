{
  "language": "Solidity",
  "sources": {
    "contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: Proprietary\npragma solidity 0.7.5;\n\ninterface IERC20 {\n    function decimals() external view returns (uint8);\n\n    /**\n    * @dev Returns the amount of tokens in existence.\n    */\n    function totalSupply() external view returns (uint256);\n\n    /**\n    * @dev Returns the amount of tokens owned by `account`.\n    */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n    * @dev Moves `amount` tokens from the caller's account to `recipient`.\n    *\n    * Returns a boolean value indicating whether the operation succeeded.\n    *\n    * Emits a {Transfer} event.\n    */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n    * @dev Returns the remaining number of tokens that `spender` will be\n    * allowed to spend on behalf of `owner` through {transferFrom}. This is\n    * zero by default.\n    *\n    * This value changes when {approve} or {transferFrom} are called.\n    */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n    * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n    *\n    * Returns a boolean value indicating whether the operation succeeded.\n    *\n    * IMPORTANT: Beware that changing an allowance with this method brings the risk\n    * that someone may use both the old and the new allowance by unfortunate\n    * transaction ordering. One possible solution to mitigate this race\n    * condition is to first reduce the spender's allowance to 0 and set the\n    * desired value afterwards:\n    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    *\n    * Emits an {Approval} event.\n    */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n    * @dev Moves `amount` tokens from `sender` to `recipient` using the\n    * allowance mechanism. `amount` is then deducted from the caller's\n    * allowance.\n    *\n    * Returns a boolean value indicating whether the operation succeeded.\n    *\n    * Emits a {Transfer} event.\n    */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n    * @dev Emitted when `value` tokens are moved from one account (`from`) to\n    * another (`to`).\n    *\n    * Note that `value` may be zero.\n    */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n    * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n    * a call to {approve}. `value` is the new allowance.\n    */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}"
    },
    "contracts/WorldOneERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.7.5;\nimport \"./interfaces/IERC20.sol\";\nimport \"./libs/LowGasSafeMath.sol\";\n\nabstract contract ERC20 is IERC20 {\n\n  using LowGasSafeMath for uint256;\n    \n  // Present in ERC777\n  mapping (address => uint256) internal _balances;\n\n  // Present in ERC777\n  mapping (address => mapping (address => uint256)) internal _allowances;\n\n  // Present in ERC777\n  uint256 internal _totalSupply;\n\n  // Present in ERC777\n  string internal _name;\n    \n  // Present in ERC777\n  string internal _symbol;\n    \n  // Present in ERC777\n  uint8 internal _decimals;\n\n  constructor (string memory name_, string memory symbol_, uint8 decimals_) {\n    _name = name_;\n    _symbol = symbol_;\n    _decimals = decimals_;\n  }\n\n  function name() public view returns (string memory) {\n    return _name;\n  }\n\n  function symbol() public view returns (string memory) {\n    return _symbol;\n  }\n\n  function decimals() public view override returns (uint8) {\n    return _decimals;\n  }\n\n  function totalSupply() public view override returns (uint256) {\n    return _totalSupply;\n  }\n\n  function balanceOf(address account) public view virtual override returns (uint256) {\n    return _balances[account];\n  }\n\n  function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n    _transfer(msg.sender, recipient, amount);\n    return true;\n  }\n\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, msg.sender, _allowances[sender][msg.sender]\n          .sub(amount));\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender]\n          .sub(subtractedValue));\n        return true;\n    }\n\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n      require(sender != address(0), \"ERC20: transfer from the zero address\");\n      require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n      _beforeTokenTransfer(sender, recipient, amount);\n\n      _balances[sender] = _balances[sender].sub(amount);\n      _balances[recipient] = _balances[recipient].add(amount);\n      emit Transfer(sender, recipient, amount);\n    }\n\n    function _mint(address account_, uint256 amount_) internal virtual {\n        require(account_ != address(0), \"ERC20: mint to the zero address\");\n        _beforeTokenTransfer(address( this ), account_, amount_);\n        _totalSupply = _totalSupply.add(amount_);\n        _balances[account_] = _balances[account_].add(amount_);\n        emit Transfer(address(0), account_, amount_);\n    }\n\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount);\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n  function _beforeTokenTransfer( address from_, address to_, uint256 amount_ ) internal virtual { }\n}\n\nlibrary Counters {\n    using LowGasSafeMath for uint256;\n\n    struct Counter {\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        counter._value += 1;\n    }\n\n    function decrement(Counter storage counter) internal {\n        counter._value = counter._value.sub(1);\n    }\n}\n\ninterface IERC2612Permit {\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    function nonces(address owner) external view returns (uint256);\n}\n\nabstract contract ERC20Permit is ERC20, IERC2612Permit {\n    using Counters for Counters.Counter;\n\n    mapping(address => Counters.Counter) private _nonces;\n\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n    bytes32 public DOMAIN_SEPARATOR;\n\n    constructor() {\n        uint256 chainID;\n        assembly {\n            chainID := chainid()\n        }\n\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                keccak256(bytes(name())),\n                keccak256(bytes(\"1\")), // Version\n                chainID,\n                address(this)\n            )\n        );\n    }\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= deadline, \"Permit: expired deadline\");\n\n        bytes32 hashStruct =\n            keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, amount, _nonces[owner].current(), deadline));\n\n        bytes32 _hash = keccak256(abi.encodePacked(uint16(0x1901), DOMAIN_SEPARATOR, hashStruct));\n\n        address signer = ecrecover(_hash, v, r, s);\n        require(signer != address(0) && signer == owner, \"ERC20Permit: Invalid signature\");\n\n        _nonces[owner].increment();\n        _approve(owner, spender, amount);\n    }\n\n    function nonces(address owner) public view override returns (uint256) {\n        return _nonces[owner].current();\n    }\n}\n\ninterface IOwnable {\n  function owner() external view returns (address);\n\n  function renounceOwnership() external;\n  \n  function transferOwnership( address newOwner_ ) external;\n}\n\ncontract Ownable is IOwnable {\n    \n  address internal _owner;\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n  constructor () {\n    _owner = msg.sender;\n    emit OwnershipTransferred( address(0), _owner );\n  }\n\n  function owner() public view override returns (address) {\n    return _owner;\n  }\n\n  modifier onlyOwner() {\n    require( _owner == msg.sender, \"Ownable: caller is not the owner\" );\n    _;\n  }\n\n  function renounceOwnership() public virtual override onlyOwner() {\n    emit OwnershipTransferred( _owner, address(0) );\n    _owner = address(0);\n  }\n\n  function transferOwnership( address newOwner_ ) public virtual override onlyOwner() {\n    require( newOwner_ != address(0), \"Ownable: new owner is the zero address\");\n    emit OwnershipTransferred( _owner, newOwner_ );\n    _owner = newOwner_;\n  }\n}\n\ncontract VaultOwned is Ownable {\n  \n  address internal _vault;\n\n  event VaultTransferred(address indexed newVault);\n\n  function setVault( address vault_ ) external onlyOwner() {\n    require(vault_ != address(0), \"IA0\");\n    _vault = vault_;\n    emit VaultTransferred( _vault );\n  }\n\n  function vault() public view returns (address) {\n    return _vault;\n  }\n\n  modifier onlyVault() {\n    require( _vault == msg.sender, \"VaultOwned: caller is not the Vault\" );\n    _;\n  }\n\n}\n\ncontract WorldOneERC20Token is ERC20Permit, VaultOwned {\n\n    using LowGasSafeMath for uint256;\n\n    constructor() ERC20(\"WorldOne\", \"WORLDONE\", 9) {\n    }\n\n    function mint(address account_, uint256 amount_) external onlyVault() {\n        _mint(account_, amount_);\n    }\n\n    function burn(uint256 amount) external virtual {\n        _burn(msg.sender, amount);\n    }\n     \n    function burnFrom(address account_, uint256 amount_) external virtual {\n        _burnFrom(account_, amount_);\n    }\n\n    function _burnFrom(address account_, uint256 amount_) internal virtual {\n        uint256 decreasedAllowance_ =\n            allowance(account_, msg.sender).sub(amount_);\n\n        _approve(account_, msg.sender, decreasedAllowance_);\n        _burn(account_, amount_);\n    }\n}"
    },
    "contracts/libs/LowGasSafeMath.sol": {
      "content": "// SPDX-License-Identifier: Proprietary\npragma solidity 0.7.5;\n\nlibrary LowGasSafeMath {\n    /// @notice Returns x + y, reverts if sum overflows uint256\n    /// @param x The augend\n    /// @param y The addend\n    /// @return z The sum of x and y\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x);\n    }\n\n    function add32(uint32 x, uint32 y) internal pure returns (uint32 z) {\n        require((z = x + y) >= x);\n    }\n\n    /// @notice Returns x - y, reverts if underflows\n    /// @param x The minuend\n    /// @param y The subtrahend\n    /// @return z The difference of x and y\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) <= x);\n    }\n\n    function sub32(uint32 x, uint32 y) internal pure returns (uint32 z) {\n        require((z = x - y) <= x);\n    }\n\n    /// @notice Returns x * y, reverts if overflows\n    /// @param x The multiplicand\n    /// @param y The multiplier\n    /// @return z The product of x and y\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(x == 0 || (z = x * y) / x == y);\n    }\n\n    function mul32(uint32 x, uint32 y) internal pure returns (uint32 z) {\n        require(x == 0 || (z = x * y) / x == y);\n    }\n\n    /// @notice Returns x + y, reverts if overflows or underflows\n    /// @param x The augend\n    /// @param y The addend\n    /// @return z The sum of x and y\n    function add(int256 x, int256 y) internal pure returns (int256 z) {\n        require((z = x + y) >= x == (y >= 0));\n    }\n\n    /// @notice Returns x - y, reverts if overflows or underflows\n    /// @param x The minuend\n    /// @param y The subtrahend\n    /// @return z The difference of x and y\n    function sub(int256 x, int256 y) internal pure returns (int256 z) {\n        require((z = x - y) <= x == (y >= 0));\n    }\n\n    function div(uint256 x, uint256 y) internal pure returns(uint256 z){\n        require(y > 0);\n        z=x/y;\n    }\n}"
    },
    "contracts/WarrantDepository.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.7.5;\npragma abicoder v2;\n\nimport \"./libs/LowGasSafeMath.sol\";\nimport \"./libs/Address.sol\";\nimport \"./libs/SafeERC20.sol\";\nimport \"./libs/FullMath.sol\";\nimport \"./libs/FixedPoint.sol\";\nimport \"./interfaces/ITreasury.sol\";\nimport \"./interfaces/IPangolinFactory.sol\";\nimport \"./interfaces/IPangolinPair.sol\";\nimport \"./utils/Ownable.sol\";\n\ncontract WorldOneWarrantDepository is Ownable {\n\n    using FixedPoint for *;\n    using SafeERC20 for IERC20;\n    using LowGasSafeMath for uint;\n    using LowGasSafeMath for uint32;\n\n    /* ======== EVENTS ======== */\n    event WarrantCreated( uint deposit, uint indexed payout, uint indexed expires, uint indexed priceInUSD );\n    event WarrantRedeemed( address indexed recipient, uint payout, uint remaining );\n    event WarrantPriceChanged( uint indexed priceInUSD, uint indexed internalPrice );\n    event InitWarrantLot( WarrantLot terms);\n    event LogSetFactory(address _factory);\n    event LogRecoverLostToken( address indexed tokenToRecover, uint amount);\n\n\n\n    /* ======== STATE VARIABLES ======== */\n\n    IERC20 public immutable WorldOne; // token given as payment for warrant\n    IERC20 public immutable principle; // token used to create warrant\n    ITreasury public immutable treasury; // mints WorldOne when receives principle\n    address public immutable DAO; // receives profit share from warrant\n    IPangolinFactory public immutable dexFactory; // Factory address to get market price\n\n    mapping( address => Warrant ) public warrantInfo; // stores warrant information for depositors\n\n    uint public warrantLotIndex = 0;\n\n    uint32 constant MAX_PAYOUT_IN_PERCENTAGE = 100000; // in thousandths of a %. i.e. 500 = 0.5%\n    uint32 constant MIN_VESTING_TERM = 129600; // in seconds. i.e. 1 day = 86400 seconds\n    uint32 constant MAX_ALLOWED_DISCOUNT = 50000; // in thousandths of a %. i.e. 50000 = 50.00%\n\n\n    /* ======== STRUCTS ======== */\n\n    // Info for warrant holder\n    struct Warrant {\n        uint payout; // WorldOne remaining to be paid\n        uint pricePaid; // In DAI, for front end viewing\n        uint32 purchasedAt; // When the warrant was purchased in block number/timestamp\n        uint32 warrantLotID; // ID of warrant lot\n    }\n\n    struct WarrantLot {\n        uint discount; // discount variable\n        uint32 vestingTerm; // in seconds\n        uint totalCapacity; // Maximum amount of tokens that can be issued\n        uint consumed; // Amount of tokens that have been issued\n        uint fee; // as % of warrant payout, in hundreths. ( 500 = 5% = 0.05 for every 1 paid)\n        uint maxPayout; // in thousandths of a %. i.e. 500 = 0.5%\n        uint price; // price of a bond in given bond lot\n    }\n\n    mapping(uint256 => WarrantLot) public warrantLots;\n\n\n    /* ======== INITIALIZATION ======== */\n\n    constructor ( \n        address _WorldOne,\n        address _principle,\n        address _treasury, \n        address _DAO,\n        address _factory\n    ) {\n        require( _WorldOne != address(0) );\n        WorldOne = IERC20(_WorldOne);\n        require( _principle != address(0) );\n        principle = IERC20(_principle);\n        require( _treasury != address(0) );\n        treasury = ITreasury(_treasury);\n        require( _DAO != address(0) );\n        DAO = _DAO;\n        require( _factory != address(0) );\n        dexFactory = IPangolinFactory( _factory );\n    }\n\n    /**\n     *  @notice initializes warrant lot parameters\n     *  @param _discount uint\n     *  @param _vestingTerm uint32\n     *  @param _totalCapacity uint\n     *  @param _fee uint\n     *  @param _maxPayout uint\n     *  @param _minimumPrice uint\n     */\n    function initializeWarrantLot( \n        uint _discount, \n        uint32 _vestingTerm,\n        uint _totalCapacity,\n        uint _fee,\n        uint _maxPayout,\n        uint _minimumPrice\n    ) external onlyOwner() {\n        require( _discount > 0, \"Discount must be greater than 0\");\n        require( _discount <= MAX_ALLOWED_DISCOUNT, \"Discount must be greater than 0\");\n        require( _vestingTerm >= MIN_VESTING_TERM, \"Vesting must be longer than 36 hours\" );\n        require( _totalCapacity > 0, \"Total capacity must be greater than 0\" );\n        require( _fee <= 10000, \"DAO fee cannot exceed payout\" );\n        require( _maxPayout <= MAX_PAYOUT_IN_PERCENTAGE, \"Payout cannot be above 100 percent\" );\n        require( _minimumPrice > 0, \"Minimum price must be greater than 0\" );\n        if( warrantLotIndex > 0 ){\n            require( currentWarrantLot().consumed == currentWarrantLot().totalCapacity, \"Warrant lot already in progress\" );\n        }\n        uint _price = getLatestPrice();\n        if( _price < _minimumPrice ){\n            _price = _minimumPrice;\n        }\n        WarrantLot memory warrantLot = WarrantLot ({\n            discount: _discount,\n            vestingTerm: _vestingTerm,\n            totalCapacity: _totalCapacity.mul( 10**WorldOne.decimals() ),\n            consumed: 0,\n            fee: _fee,\n            maxPayout: _maxPayout,\n            price: _price\n        });\n        warrantLots[warrantLotIndex] = warrantLot;\n        warrantLotIndex += 1;\n        emit InitWarrantLot(warrantLot);\n        emit WarrantPriceChanged( warrantPriceInUSD(), warrantPrice() );\n    }\n\n    \n    /* ======== POLICY FUNCTIONS ======== */\n\n\n\n    \n\n    /* ======== USER FUNCTIONS ======== */\n\n\n    /**\n     *  @notice deposit warrant\n     *  @param _amount uint\n     *  @param _maxPrice uint\n     *  @param _depositor address\n     *  @return uint\n     */\n    function deposit( \n        uint _amount, \n        uint _maxPrice,\n        address _depositor\n    ) external returns ( uint ) {\n        require( _depositor != address(0), \"Invalid address\" );\n        require(msg.sender == _depositor);\n        require(warrantLotIndex > 0, \"Warrant lot has not been initialized\");\n        require( isPurchasable(), \"Market price must be greater than warrant lot price\" );\n        uint priceInUSD = warrantPriceInUSD(); // Stored in warrant info\n        uint nativePrice = warrantPrice();\n\n        require( _maxPrice >= nativePrice, \"Slippage limit: more than max price\" ); // slippage protection\n\n        uint value = treasury.convertToken( address(principle), _amount );\n        \n        uint payout = payoutFor( value ); // payout to warranter is computed\n\n        require( payout >= 10_000_000, \"Warrant too small\" ); // must be > 0.01 WorldOne ( underflow protection )\n        require( payout <= maxPayout(), \"Warrant too large\"); // size protection because there is no slippage\n        require(currentWarrantLot().consumed.add(payout) <= currentWarrantLot().totalCapacity, \"Exceeding maximum allowed purchase in current warrant lot\");\n\n        uint fee = payout.mul( currentWarrantLot().fee ) / 100_00 ;\n\n        principle.safeTransferFrom( msg.sender, address(this), _amount );\n        principle.approve( address( treasury ), _amount );\n\n        treasury.deposit( _amount, address(principle), fee );\n        if ( fee != 0 ) { // fee is transferred to dao \n            WorldOne.safeTransfer( DAO, fee ); \n        }\n\n        // depositor info is stored\n        warrantInfo[ _depositor ] = Warrant({ \n            payout: warrantInfo[ _depositor ].payout.add( payout ),\n            warrantLotID: uint32(warrantLotIndex - 1),\n            purchasedAt: uint32(block.timestamp),\n            pricePaid: priceInUSD\n        });\n\n        warrantLots[ warrantLotIndex - 1 ] = WarrantLot({\n            discount: currentWarrantLot().discount,\n            vestingTerm: currentWarrantLot().vestingTerm,\n            totalCapacity: currentWarrantLot().totalCapacity,\n            consumed: currentWarrantLot().consumed.add(payout),\n            fee: currentWarrantLot().fee,\n            maxPayout: currentWarrantLot().maxPayout,\n            price: currentWarrantLot().price\n        });\n\n        emit WarrantCreated( _amount, payout, block.timestamp.add( currentWarrantLot().vestingTerm ), priceInUSD );\n\n        return payout; \n    }\n\n\n    /** \n     *  @notice redeem warrant for user\n     *  @param _recipient address\n     *  @return uint\n     */ \n    function redeem( address _recipient ) external returns ( uint ) {\n        require(msg.sender == _recipient, \"NA\");     \n        Warrant memory info = warrantInfo[ _recipient ];\n        require( uint32(block.timestamp) >= info.purchasedAt.add32( warrantLots[info.warrantLotID].vestingTerm )  , \"Cannot redeem before vesting period is over\");\n        delete warrantInfo[ _recipient ]; // delete user info\n        emit WarrantRedeemed( _recipient, info.payout, 0 ); // emit warrant data\n        return send( _recipient, info.payout ); // pay user everything due\n    }\n\n\n    /**\n     *  @notice get remaining WorldOne available in current warrant lot\n     *  @return uint\n     */\n    function remainingAvailable() public view returns ( uint ) {\n        return currentWarrantLot().totalCapacity.sub( currentWarrantLot().consumed );\n    }\n\n    /**\n     *  @notice Get cost of all remaining WorldOne tokens\n     *  @return uint\n     */\n    function allCost() public view returns (uint) {\n        return remainingAvailable().mul( 10**principle.decimals() ).mul( warrantPrice() ).div( 10**WorldOne.decimals() ) / 100;\n    }\n\n\n    \n    /* ======== INTERNAL HELPER FUNCTIONS ======== */\n\n\n    /**\n     *  @notice check if warrant is purchaseable\n     *  @return bool\n     */\n    function isPurchasable() internal view returns(bool) {\n        uint price = warrantPrice(); // 1100 x \n        price = price.mul(10**principle.decimals())/100;\n        if ( price < getMarketPrice() ) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     *  @notice get current market price\n     *  @return uint\n     */\n    function getMarketPrice() internal view returns(uint) {\n        IPangolinPair pair = IPangolinPair(dexFactory.getPair(address(principle), address(WorldOne)));\n        IERC20 token1 = IERC20(pair.token1());\n        (uint Res0, uint Res1,) = pair.getReserves();\n\n        // decimals\n        uint res0 = Res0*(10**token1.decimals());\n        return(res0/Res1); // return _amount of token0 needed to buy token1 :: token0 = DAI, token1 = WorldOne\n    }\n\n    /**\n     *  @notice allow user to send payout\n     *  @param _amount uint\n     *  @return uint\n     */\n    function send( address _recipient, uint _amount ) internal returns ( uint ) {\n        WorldOne.transfer( _recipient, _amount ); // send payout       \n        return _amount;\n    }\n\n    /**\n     *  @notice get current warrant lot terms\n     *  @return WarrantLot\n     */\n    function currentWarrantLot() internal view returns ( WarrantLot memory ) {\n        require( warrantLotIndex > 0, \"No bond lot has been initialised\");\n        return warrantLots[ warrantLotIndex - 1 ];\n    } \n\n    /* ======== VIEW FUNCTIONS ======== */\n\n    /**\n     *  @notice determine maximum warrant size\n     *  @return uint\n     */\n    function maxPayout() public view returns ( uint ) {\n        return currentWarrantLot().totalCapacity.mul( currentWarrantLot().maxPayout ) / 100000;\n    }\n\n    /**\n     *  @notice calculate interest due for new warrant\n     *  @param _value uint\n     *  @return uint\n     */\n    function payoutFor( uint _value ) public view returns ( uint ) {\n        return FixedPoint.fraction( _value, warrantPrice() ).decode112with18() / 1e16 ;\n    }\n\n    /**\n     *  @notice calculate value of token via token amount\n     *  @param _amount uint\n     *  @return uint\n     */\n    function valueOf( uint _amount ) external view returns ( uint ) {\n        return FixedPoint.fraction( _amount, warrantPrice() ).decode112with18() / 1e16 ;\n    }\n\n    /**\n     *  @notice calculate current warrant premium\n     *  @return price_ uint\n     */\n    function warrantPrice() public view returns ( uint price_ ) {\n        price_ = currentWarrantLot().price;\n    }\n\n    function getLatestPrice() public view returns ( uint price_ ) {\n        uint circulatingSupply = WorldOne.totalSupply();\n        uint treasuryBalance = treasury.getTotalReserves().mul(1e9); //IERC20(principle).balanceOf(address(treasury));\n        if (circulatingSupply == 0) { // On first warrant sale, there will be no circulating supply\n            price_ = 0;\n        } else {\n            price_ = treasuryBalance.div(circulatingSupply).mul(getYieldFactor()).div(1e11);\n        }\n    }\n\n\n    function getYieldFactor() public view returns ( uint ) {\n        return currentWarrantLot().discount.add( 1e4 ); // add extra 100_00 to add 100% to original discount value\n    }\n\n\n    /**\n     *  @notice converts warrant price to DAI value\n     *  @return price_ uint\n     */\n    function warrantPriceInUSD() public view returns ( uint price_ ) {\n        price_ = warrantPrice().mul( 10 ** principle.decimals() ) / 100;\n    }\n\n\n    /* ======= AUXILLIARY ======= */\n\n    /**\n     *  @notice allow anyone to send lost tokens (excluding principle or WorldOne) to the DAO\n     *  @return bool\n     */\n    function recoverLostToken(IERC20 _token ) external returns ( bool ) {\n        require( _token != WorldOne, \"NAT\" );\n        require( _token != principle, \"NAP\" );\n        uint balance = _token.balanceOf( address(this));\n        _token.safeTransfer( DAO,  balance );\n        emit LogRecoverLostToken(address(_token), balance);\n        return true;\n    }\n}"
    },
    "contracts/libs/Address.sol": {
      "content": "// SPDX-License-Identifier: Proprietary\npragma solidity 0.7.5;\n\nlibrary Address {\n\n      function isContract(address account) internal view returns (bool) {\n        // This method relies in extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    function functionCall(\n        address target, \n        bytes memory data, \n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    function functionCallWithValue(\n        address target, \n        bytes memory data, \n        uint256 value, \n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _functionCallWithValue(\n        address target, \n        bytes memory data, \n        uint256 weiValue, \n        string memory errorMessage\n    ) private returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    function functionStaticCall(\n        address target, \n        bytes memory data, \n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    function functionDelegateCall(\n        address target, \n        bytes memory data, \n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(\n        bool success, \n        bytes memory returndata, \n        string memory errorMessage\n    ) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            if (returndata.length > 0) {\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n\n    function addressToString(address _address) internal pure returns(string memory) {\n        bytes32 _bytes = bytes32(uint256(_address));\n        bytes memory HEX = \"0123456789abcdef\";\n        bytes memory _addr = new bytes(42);\n\n        _addr[0] = '0';\n        _addr[1] = 'x';\n\n        for(uint256 i = 0; i < 20; i++) {\n            _addr[2+i*2] = HEX[uint8(_bytes[i + 12] >> 4)];\n            _addr[3+i*2] = HEX[uint8(_bytes[i + 12] & 0x0f)];\n        }\n\n        return string(_addr);\n\n    }\n}"
    },
    "contracts/libs/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: Proprietary\npragma solidity 0.7.5;\n\nimport \"./LowGasSafeMath.sol\";\nimport \"./Address.sol\";\nimport \"./../interfaces/IERC20.sol\";\n\nlibrary SafeERC20 {\n    using LowGasSafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender)\n            .sub(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/libs/FullMath.sol": {
      "content": "// SPDX-License-Identifier: Proprietary\npragma solidity 0.7.5;\n\nlibrary FullMath {\n    function fullMul(uint256 x, uint256 y) private pure returns (uint256 l, uint256 h) {\n        uint256 mm = mulmod(x, y, uint256(-1));\n        l = x * y;\n        h = mm - l;\n        if (mm < l) h -= 1;\n    }\n\n    function fullDiv(\n        uint256 l,\n        uint256 h,\n        uint256 d\n    ) private pure returns (uint256) {\n        uint256 pow2 = d & -d;\n        d /= pow2;\n        l /= pow2;\n        l += h * ((-pow2) / pow2 + 1);\n        uint256 r = 1;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        return l * r;\n    }\n\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 d\n    ) internal pure returns (uint256) {\n        (uint256 l, uint256 h) = fullMul(x, y);\n        uint256 mm = mulmod(x, y, d);\n        if (mm > l) h -= 1;\n        l -= mm;\n        require(h < d, 'FullMath::mulDiv: overflow');\n        return fullDiv(l, h, d);\n    }\n}"
    },
    "contracts/libs/FixedPoint.sol": {
      "content": "// SPDX-License-Identifier: Proprietary\npragma solidity 0.7.5;\n\nimport \"./FullMath.sol\";\n\nlibrary FixedPoint {\n\n    struct uq112x112 {\n        uint224 _x;\n    }\n\n    struct uq144x112 {\n        uint256 _x;\n    }\n\n    uint8 private constant RESOLUTION = 112;\n    uint256 private constant Q112 = 0x10000000000000000000000000000;\n    uint256 private constant Q224 = 0x100000000000000000000000000000000000000000000000000000000;\n    uint256 private constant LOWER_MASK = 0xffffffffffffffffffffffffffff; // decimal of UQ*x112 (lower 112 bits)\n\n    function decode(uq112x112 memory self) internal pure returns (uint112) {\n        return uint112(self._x >> RESOLUTION);\n    }\n\n    function decode112with18(uq112x112 memory self) internal pure returns (uint) {\n\n        return uint(self._x) / 5192296858534827;\n    }\n\n    function fraction(uint256 numerator, uint256 denominator) internal pure returns (uq112x112 memory) {\n        require(denominator > 0, 'FixedPoint::fraction: division by zero');\n        if (numerator == 0) return FixedPoint.uq112x112(0);\n\n        if (numerator <= uint144(-1)) {\n            uint256 result = (numerator << RESOLUTION) / denominator;\n            require(result <= uint224(-1), 'FixedPoint::fraction: overflow');\n            return uq112x112(uint224(result));\n        } else {\n            uint256 result = FullMath.mulDiv(numerator, Q112, denominator);\n            require(result <= uint224(-1), 'FixedPoint::fraction: overflow');\n            return uq112x112(uint224(result));\n        }\n    }\n}\n"
    },
    "contracts/interfaces/ITreasury.sol": {
      "content": "// SPDX-License-Identifier: Proprietary\npragma solidity 0.7.5;\n\ninterface ITreasury {\n    function deposit( uint _amount, address _token, uint _fee ) external returns ( uint );\n    function valueOf( address _token, uint _amount ) external view returns ( uint value_ );\n    function convertToken( address _token, uint _amount ) external view returns ( uint value_ );\n    function getTotalReserves() external view returns (uint);\n}"
    },
    "contracts/interfaces/IPangolinFactory.sol": {
      "content": "// SPDX-License-Identifier: Proprietary\npragma solidity 0.7.5;\n\ninterface IPangolinFactory {\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}"
    },
    "contracts/interfaces/IPangolinPair.sol": {
      "content": "// SPDX-License-Identifier: Proprietary\npragma solidity 0.7.5;\n\ninterface IPangolinPair {\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}"
    },
    "contracts/utils/Ownable.sol": {
      "content": "// SPDX-License-Identifier: Proprietary\npragma solidity 0.7.5;\n\ncontract OwnableData {\n    address public owner;\n    address public pendingOwner;\n}\n\ncontract Ownable is OwnableData {\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /// @notice `owner` defaults to msg.sender on construction.\n    constructor() {\n        owner = msg.sender;\n        emit OwnershipTransferred(address(0), msg.sender);\n    }\n\n    /// @notice Transfers ownership to `newOwner`. Either directly or claimable by the new pending owner.\n    /// Can only be invoked by the current `owner`.\n    /// @param newOwner Address of the new owner.\n    /// @param direct True if `newOwner` should be set immediately. False if `newOwner` needs to use `claimOwnership`.\n    /// @param renounce Allows the `newOwner` to be `address(0)` if `direct` and `renounce` is True. Has no effect otherwise.\n    function transferOwnership(\n        address newOwner,\n        bool direct,\n        bool renounce\n    ) public onlyOwner {\n        if (direct) {\n            // Checks\n            require(newOwner != address(0) || renounce, \"Ownable: zero address\");\n\n            // Effects\n            emit OwnershipTransferred(owner, newOwner);\n            owner = newOwner;\n            pendingOwner = address(0);\n        } else {\n            // Effects\n            pendingOwner = newOwner;\n        }\n    }\n\n    /// @notice Needs to be called by `pendingOwner` to claim ownership.\n    function claimOwnership() public {\n        address _pendingOwner = pendingOwner;\n\n        // Checks\n        require(msg.sender == _pendingOwner, \"Ownable: caller != pending owner\");\n\n        // Effects\n        emit OwnershipTransferred(owner, _pendingOwner);\n        owner = _pendingOwner;\n        pendingOwner = address(0);\n    }\n\n    /// @notice Only allows the `owner` to execute the function.\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Ownable: caller is not the owner\");\n        _;\n    }\n}\n"
    },
    "contracts/Treasury.sol": {
      "content": "// SPDX-License-Identifier: Proprietary\npragma solidity 0.7.5;\n\nimport \"./libs/LowGasSafeMath.sol\";\nimport \"./libs/SafeERC20.sol\";\nimport \"./interfaces/ITreasury.sol\";\nimport \"./utils/Ownable.sol\";\nimport \"./interfaces/IERC20Mintable.sol\";\nimport \"./interfaces/IWorldOneERC20.sol\";\nimport \"./interfaces/IWarrantDepository.sol\";\n\ncontract WorldOneTreasury is Ownable {\n\n    using LowGasSafeMath for uint;\n    using LowGasSafeMath for uint32;\n    using SafeERC20 for IERC20;\n\n    event Deposit( address indexed token, uint amount, uint value );\n    event Withdrawal( address indexed token, uint amount, uint totalWithdrawal );\n    event CreateDebt( address indexed debtor, address indexed token, uint amount, uint value );\n    event RepayDebt( address indexed debtor, address indexed token, uint amount, uint value );\n    event Payback( address indexed token, uint amount, uint totalReserves, uint paidExtra );\n    event ReservesManaged( address indexed token, uint amount );\n    event ReservesUpdated( uint indexed totalReserves );\n    event ReservesAudited( uint indexed totalReserves );\n    event ChangeQueued( MANAGING indexed managing, address queued );\n    event ChangeActivated( MANAGING indexed managing, address activated, bool result );\n    event ChangeLimitAmount( uint256 amount );\n\n    enum MANAGING { \n        RESERVEDEPOSITOR, \n        RESERVESPENDER, \n        RESERVETOKEN, \n        RESERVEMANAGER, \n        DEBTOR, \n        REWARDMANAGER\n    }\n\n    IWorldOneERC20 public immutable WorldOne;\n    uint32 public immutable secondsNeededForQueue;\n    IWarrantDepository public warrantDepository;\n\n    address[] public reserveTokens; // Push only, beware false-positives.\n    mapping( address => bool ) public isReserveToken;\n    mapping( address => uint32 ) public reserveTokenQueue; // Delays changes to mapping.\n\n    address[] public reserveDepositors; // Push only, beware false-positives. Only for viewing.\n    mapping( address => bool ) public isReserveDepositor;\n    mapping( address => uint32 ) public reserveDepositorQueue; // Delays changes to mapping.\n\n    address[] public reserveSpenders; // Push only, beware false-positives. Only for viewing.\n    mapping( address => bool ) public isReserveSpender;\n    mapping( address => uint32 ) public reserveSpenderQueue; // Delays changes to mapping.\n\n    address[] public reserveManagers; // Push only, beware false-positives. Only for viewing.\n    mapping( address => bool ) public isReserveManager;\n    mapping( address => uint32 ) public ReserveManagerQueue; // Delays changes to mapping.\n\n    address[] public debtors; // Push only, beware false-positives. Only for viewing.\n    mapping( address => bool ) public isDebtor;\n    mapping( address => uint32 ) public debtorQueue; // Delays changes to mapping.\n    mapping( address => uint ) public debtorBalance;\n\n    address[] public rewardManagers; // Push only, beware false-positives. Only for viewing.\n    mapping( address => bool ) public isRewardManager;\n    mapping( address => uint32 ) public rewardManagerQueue; // Delays changes to mapping.\n\n    mapping( address => uint256 ) public hourlyLimitAmounts; // tracks amounts\n    mapping( address => uint32 ) public hourlyLimitQueue; // Delays changes to mapping.\n\n    uint256 public limitAmount;\n    \n    uint public totalReserves; // Risk-free value of all assets\n    uint public totalWithdraw;\n\n    constructor (\n        address _WorldOne,\n        address _MIM,\n        uint32 _secondsNeededForQueue,\n        uint256 _limitAmount\n    ) {\n        require( _WorldOne != address(0) );\n        WorldOne = IWorldOneERC20(_WorldOne);\n\n        isReserveToken[ _MIM ] = true;\n        reserveTokens.push( _MIM );\n\n        secondsNeededForQueue = _secondsNeededForQueue;\n        limitAmount = _limitAmount;\n    }\n\n    function setLimitAmount(uint amount) external onlyOwner {\n        limitAmount = amount;\n        emit ChangeLimitAmount(limitAmount);\n    }\n\n    /**\n        @notice allow approved address to deposit an asset for WorldOne\n        @param _amount uint\n        @param _token address\n        @param _fee uint\n        @return send_ uint\n     */\n    function deposit( uint _amount, address _token, uint _fee ) external returns ( uint send_ ) {\n        require( isReserveToken[ _token ], \"Not accepted\" );\n        uint value = convertToken(_token, _amount);\n        send_ = valueOf(_token, _amount);\n        send_ = send_.add( _fee );\n\n        IERC20( _token ).safeTransferFrom( msg.sender, address(this), _amount );\n\n        if ( isReserveToken[ _token ] ) {\n            require( isReserveDepositor[ msg.sender ], \"Not approved\" );\n        }\n        WorldOne.mint( msg.sender, send_ );\n\n        totalReserves = totalReserves.add( value );\n        emit ReservesUpdated( totalReserves );\n\n        emit Deposit( _token, _amount, value );\n    }\n\n    /**\n        @notice allow approved address to withdraw reserves\n        @param _amount uint\n        @param _token address\n     */\n    function withdraw( uint _amount, address _token ) external {\n        require( isReserveToken[ _token ], \"Not accepted\" ); // Only reserves can be used for redemptions\n        require( isReserveSpender[ msg.sender ], \"Not approved\" );\n        require ( _amount <= totalReserves, \"Cannot withdraw more than treasury currently holds\");\n        totalWithdraw = totalWithdraw.add( _amount );\n        IERC20( _token ).safeTransfer( msg.sender, _amount );\n\n        emit Withdrawal( _token, _amount, totalWithdraw );\n    }\n\n    /**\n        @notice allow approved address to add funds back in treasury\n        @param _amount uint\n        @param _token address\n     */\n\n    function addBack(uint _amount, address _token) external {\n        require( isReserveToken[ _token ], \"Not accepted\" ); // Only reserves can be used for redemptions\n        require( isReserveSpender[ msg.sender ], \"Not approved\" );\n        uint balance;\n        if ( totalWithdraw >= _amount ) {\n            totalWithdraw = totalWithdraw.sub( _amount );\n        } else {\n            balance = _amount.sub( totalWithdraw );\n            totalReserves = totalReserves.add( balance );\n            totalWithdraw = 0;\n        }\n        IERC20( _token ).safeTransferFrom( msg.sender, address(this), _amount );\n        emit Payback( _token, _amount, totalReserves, balance);\n\n    }\n\n    /**\n        @notice Set warrant depository address for treasury\n        @param _depo address\n     */\n    function setWarrantDepository(address _depo) external onlyOwner {\n        warrantDepository = IWarrantDepository(_depo);\n    }\n\n    /**\n        @notice get total reserves that treasury has\n        @return totalReserves uint\n     */\n    function getTotalReserves() external view returns (uint) {\n        return totalReserves;\n    }\n    \n    \n    /**\n        @notice returns WorldOne valuation of asset\n        @param _token address\n        @param _amount uint\n        @return value_ uint\n     */\n    function valueOf( address _token, uint _amount ) public view returns ( uint value_ ) {\n        if ( isReserveToken[ _token ] ) {\n            // convert amount to match WorldOne decimals\n            value_ = convertToken( _token, _amount );\n            value_ = warrantDepository.valueOf(value_);\n        }\n    }\n\n    /**\n        @notice convert token decimals to match WorldOne decimals\n        @param _token address\n        @param _amount uint\n        @return value_ uint\n     */\n    function convertToken( address _token, uint _amount ) public view returns ( uint value_ ) {\n        if ( isReserveToken[ _token ] ) {\n            // convert amount to match WorldOne decimals\n            value_ = _amount.mul( 10 ** WorldOne.decimals() ).div( 10 ** IERC20( _token ).decimals() );\n        }\n    }\n\n    /**\n        @notice queue address to change boolean in mapping\n        @param _managing MANAGING\n        @param _address address\n        @return bool\n     */\n    function queue( MANAGING _managing, address _address ) external onlyOwner returns ( bool ) {\n        require( _address != address(0), \"IA\" );\n        if ( _managing == MANAGING.RESERVEDEPOSITOR ) { // 0\n            reserveDepositorQueue[ _address ] = uint32(block.timestamp).add32( secondsNeededForQueue );\n        } else if ( _managing == MANAGING.RESERVESPENDER ) { // 1\n            reserveSpenderQueue[ _address ] = uint32(block.timestamp).add32( secondsNeededForQueue );\n        } else if ( _managing == MANAGING.RESERVETOKEN ) { // 2\n            reserveTokenQueue[ _address ] = uint32(block.timestamp).add32( secondsNeededForQueue );\n        } else if ( _managing == MANAGING.RESERVEMANAGER ) { // 3\n            ReserveManagerQueue[ _address ] = uint32(block.timestamp).add32( secondsNeededForQueue.mul32( 2 ) );\n        } else if ( _managing == MANAGING.DEBTOR ) { // 7\n            debtorQueue[ _address ] = uint32(block.timestamp).add32( secondsNeededForQueue );\n        } else if ( _managing == MANAGING.REWARDMANAGER ) { // 8\n            rewardManagerQueue[ _address ] = uint32(block.timestamp).add32( secondsNeededForQueue );\n        } else return false;\n\n        emit ChangeQueued( _managing, _address );\n        return true;\n    }\n\n    /**\n        @notice verify queue then set boolean in mapping\n        @param _managing MANAGING\n        @param _address address\n        @return bool\n     */\n    function toggle(\n        MANAGING _managing, \n        address _address\n    ) external onlyOwner returns ( bool ) {\n        require( _address != address(0), \"IA\" );\n        bool result;\n        if ( _managing == MANAGING.RESERVEDEPOSITOR ) { // 0\n            if ( requirements( reserveDepositorQueue, isReserveDepositor, _address ) ) {\n                reserveDepositorQueue[ _address ] = 0;\n                if( !listContains( reserveDepositors, _address ) ) {\n                    reserveDepositors.push( _address );\n                }\n            }\n            result = !isReserveDepositor[ _address ];\n            isReserveDepositor[ _address ] = result;\n            \n        } else if ( _managing == MANAGING.RESERVESPENDER ) { // 1\n            if ( requirements( reserveSpenderQueue, isReserveSpender, _address ) ) {\n                reserveSpenderQueue[ _address ] = 0;\n                if( !listContains( reserveSpenders, _address ) ) {\n                    reserveSpenders.push( _address );\n                }\n            }\n            result = !isReserveSpender[ _address ];\n            isReserveSpender[ _address ] = result;\n\n        } else if ( _managing == MANAGING.RESERVETOKEN ) { // 2\n            if ( requirements( reserveTokenQueue, isReserveToken, _address ) ) {\n                reserveTokenQueue[ _address ] = 0;\n                if( !listContains( reserveTokens, _address ) ) {\n                    reserveTokens.push( _address );\n                }\n            }\n            result = !isReserveToken[ _address ];\n            isReserveToken[ _address ] = result;\n\n        } else if ( _managing == MANAGING.RESERVEMANAGER ) { // 3\n            if ( requirements( ReserveManagerQueue, isReserveManager, _address ) ) {\n                reserveManagers.push( _address );\n                ReserveManagerQueue[ _address ] = 0;\n                if( !listContains( reserveManagers, _address ) ) {\n                    reserveManagers.push( _address );\n                }\n            }\n            result = !isReserveManager[ _address ];\n            isReserveManager[ _address ] = result;\n\n        } else if ( _managing == MANAGING.DEBTOR ) { // 7\n            if ( requirements( debtorQueue, isDebtor, _address ) ) {\n                debtorQueue[ _address ] = 0;\n                if( !listContains( debtors, _address ) ) {\n                    debtors.push( _address );\n                }\n            }\n            result = !isDebtor[ _address ];\n            isDebtor[ _address ] = result;\n\n        } else if ( _managing == MANAGING.REWARDMANAGER ) { // 8\n            if ( requirements( rewardManagerQueue, isRewardManager, _address ) ) {\n                rewardManagerQueue[ _address ] = 0;\n                if( !listContains( rewardManagers, _address ) ) {\n                    rewardManagers.push( _address );\n                }\n            }\n            result = !isRewardManager[ _address ];\n            isRewardManager[ _address ] = result;\n\n        } else return false;\n\n        emit ChangeActivated( _managing, _address, result );\n        return true;\n    }\n\n    /**\n        @notice checks requirements and returns altered structs\n        @param queue_ mapping( address => uint )\n        @param status_ mapping( address => bool )\n        @param _address address\n        @return bool \n     */\n    function requirements( \n        mapping( address => uint32 ) storage queue_, \n        mapping( address => bool ) storage status_, \n        address _address \n    ) internal view returns ( bool ) {\n        if ( !status_[ _address ] ) {\n            require( queue_[ _address ] != 0, \"Must queue\" );\n            require( queue_[ _address ] <= uint32(block.timestamp), \"Queue not expired\" );\n            return true;\n        } return false;\n    }\n\n    /**\n        @notice checks array to ensure against duplicate\n        @param _list address[]\n        @param _token address\n        @return bool\n     */\n    function listContains( address[] storage _list, address _token ) internal view returns ( bool ) {\n        for( uint i = 0; i < _list.length; i++ ) {\n            if( _list[ i ] == _token ) {\n                return true;\n            }\n        }\n        return false;\n    }\n}"
    },
    "contracts/interfaces/IERC20Mintable.sol": {
      "content": "// SPDX-License-Identifier: Proprietary\npragma solidity 0.7.5;\n\ninterface IERC20Mintable {\n  function mint( uint256 amount_ ) external;\n\n  function mint( address account_, uint256 ammount_ ) external;\n}"
    },
    "contracts/interfaces/IWorldOneERC20.sol": {
      "content": "// SPDX-License-Identifier: Proprietary\npragma solidity 0.7.5;\nimport \"./IERC20Mintable.sol\";\nimport \"./IERC20.sol\";\n\n\ninterface IWorldOneERC20 is IERC20Mintable, IERC20 {\n    function burnFrom(address account_, uint256 amount_) external;\n}"
    },
    "contracts/interfaces/IWarrantDepository.sol": {
      "content": "// SPDX-License-Identifier: Proprietary\npragma solidity 0.7.5;\n\ninterface IWarrantDepository {\n    function valueOf( uint _amount ) external view returns ( uint );\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}